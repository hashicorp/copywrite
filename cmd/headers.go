// Copyright IBM Corp. 2023, 2025
// SPDX-License-Identifier: MPL-2.0

package cmd

import (
	"fmt"
	"os"
	"path/filepath"
	"runtime"
	"strings"
	"sync"
	"sync/atomic"

	"github.com/hashicorp/copywrite/addlicense"
	"github.com/hashicorp/copywrite/licensecheck"
	"github.com/hashicorp/go-hclog"
	"github.com/jedib0t/go-pretty/v6/text"
	"github.com/samber/lo"
	"github.com/spf13/cobra"
)

// Flag variables
var (
	plan bool
)

var headersCmd = &cobra.Command{
	Use:   "headers",
	Short: "Adds missing copyright headers and updates existing headers' year information in all source code files",
	Long: `Recursively checks for all files in the given directory and subdirectories,
adding copyright statements and license headers to any that are missing them and
updating the year information in existing headers based on git history.

By default, the command will modify files in place. To perform a dry-run without
modifying any files, use the --plan flag.

Autogenerated files and common file types that don't support headers (e.g., prose)
will automatically be exempted. Any other files or folders should be added to the
header_ignore list in your project's .copywrite.hcl config. For help adding a
config, see the "copywrite init" command.`,
	GroupID: "common", // Let's put this command in the common section of the help
	PreRun: func(cmd *cobra.Command, args []string) {
		// Change directory if needed
		if dirPath != "." {
			err := os.Chdir(dirPath)
			cobra.CheckErr(err)
		}

		// Map command flags to config keys
		mapping := map[string]string{
			`spdx`:             `project.license`,
			`copyright-holder`: `project.copyright_holder`,
		}

		// update the running config with any command-line flags
		clobberWithDefaults := false
		err := conf.LoadCommandFlags(cmd.Flags(), mapping, clobberWithDefaults)
		if err != nil {
			cliLogger.Error("Error merging configuration", err)
		}
		cobra.CheckErr(err)

		// Input Validation
		isValidSPDX := addlicense.ValidSPDX(conf.Project.License)
		if conf.Project.License != "" && !isValidSPDX {
			err := fmt.Errorf("invalid SPDX license identifier: %s", conf.Project.License)
			cliLogger.Error("Error validating SPDX license", err)
			cobra.CheckErr(err)
		}
	},
	Run: func(cmd *cobra.Command, args []string) {
		if plan {
			cmd.Print(text.FgYellow.Sprint("Executing in dry-run mode. Rerun without the `--plan` flag to apply changes.\n\n"))
		}

		if conf.Project.License == "" {
			cmd.Printf("The --spdx flag was not specified, omitting SPDX license statements.\n\n")
		} else {
			cmd.Printf("Using license identifier: %s\n", conf.Project.License)
		}
		cmd.Printf("Using copyright holder: %v\n\n", conf.Project.CopyrightHolder)

		if len(conf.Project.HeaderIgnore) == 0 {
			cmd.Println("The project.header_ignore list was left empty in config. Processing all files by default.")
		} else {
			gha.StartGroup("Exempting the following search patterns:")
			for _, v := range conf.Project.HeaderIgnore {
				cmd.Println(text.FgCyan.Sprint(v))
			}
			gha.EndGroup()
		}
		cmd.Println("")

		// Append default ignored search patterns (e.g., GitHub Actions workflows)
		autoSkippedPatterns := []string{
			".github/workflows/**",
			".github/dependabot.yml",
			"**/node_modules/**",
			".copywrite.hcl",
			".git/**/*.pack",
		}
		ignoredPatterns := lo.Union(conf.Project.HeaderIgnore, autoSkippedPatterns)

		// STEP 1: Update existing copyright headers
		gha.StartGroup("Updating existing copyright headers:")
		updatedCount, anyFileUpdated, licensePath := updateExistingHeaders(cmd, ignoredPatterns, plan)
		gha.EndGroup()
		if updatedCount > 0 {
			if plan {
				cmd.Printf("\n%s\n\n", text.FgYellow.Sprintf("[DRY RUN] Would update %d file(s) with new copyright years", updatedCount))
			} else {
				cmd.Printf("\n%s\n\n", text.FgGreen.Sprintf("Successfully updated %d file(s) with new copyright years", updatedCount))
			}
		}

		// STEP 2: Construct the configuration addLicense needs to properly format headers
		licenseData := addlicense.LicenseData{
			Year:   conf.FormatCopyrightYears(), // Format year(s) for copyright statements
			Holder: conf.Project.CopyrightHolder,
			SPDXID: conf.Project.License,
		}

		verbose := true

		// Wrap hclogger to use standard lib's log.Logger
		stdcliLogger := cliLogger.StandardLogger(&hclog.StandardLoggerOptions{
			// InferLevels must be true so that addLicense can set the log level via
			// log prefix, e.g. logger.Println("[DEBUG] this is inferred as a debug log")
			InferLevels: true,
		})

		// WARNING: because of the way we redirect cliLogger to os.Stdout, anything
		// prefixed with "[ERROR]" will not implicitly be written to stderr.
		// However, we propagate errors upward from addlicense and then run a
		// cobra.CheckErr on the return, which will indeed output to stderr and
		// return a non-zero error code.

		// STEP 3: Add missing headers
		gha.StartGroup("Adding missing copyright headers:")
		var err error
		// In dry-run mode, if updateExistingHeaders found files that would be
		// updated (year bumps), treat that as an error so the command exits
		// non-zero to indicate work would be performed.
		if plan && updatedCount > 0 {
			err = fmt.Errorf("[DRY RUN] %d file(s) would be updated with new copyright years", updatedCount)
		}
		runErr := addlicense.Run(ignoredPatterns, "only", licenseData, "", verbose, plan, []string{"."}, stdcliLogger)
		if err != nil && runErr != nil {
			err = fmt.Errorf("%v; %v", err, runErr)
		} else if err == nil {
			err = runErr
		}
		gha.EndGroup()

		// STEP 4: Update LICENSE file if any files were modified (either updated or added headers)
		// In plan mode: if addlicense found missing headers (returns error), assume files would be modified
		// In normal mode: if addlicense succeeded, assume files were modified
		if runErr != nil || (!plan && runErr == nil) {
			anyFileUpdated = true
		}

		updateLicenseFile(cmd, licensePath, anyFileUpdated, plan)

		// Check for errors after LICENSE file update so we still show what would happen
		cobra.CheckErr(err)
	},
}

func init() {
	rootCmd.AddCommand(headersCmd)

	// These flags are only locally relevant
	headersCmd.Flags().StringVarP(&dirPath, "dirPath", "d", ".", "Path to the directory in which you wish to validate headers")
	headersCmd.Flags().BoolVar(&plan, "plan", false, "Performs a dry-run, printing the names of all files missing headers")

	// These flags will get mapped to keys in the the global Config
	headersCmd.Flags().StringP("spdx", "s", "", "SPDX-compliant license identifier (e.g., 'MPL-2.0')")
	headersCmd.Flags().StringP("copyright-holder", "c", "", "Copyright holder (default \"IBM Corp.\")")
}

// updateExistingHeaders walks through files and updates copyright headers based on config and git history
// Returns the count of updated files, a boolean indicating if any file was updated, and the LICENSE file path (if found)
func updateExistingHeaders(cmd *cobra.Command, ignoredPatterns []string, dryRun bool) (int, bool, string) {
	_ = licensecheck.InitializeGitCache(".")
	targetHolder := conf.Project.CopyrightHolder
	if targetHolder == "" {
		targetHolder = "IBM Corp."
	}

	configYear := conf.Project.CopyrightYear
	repoFirstYear, _ := licensecheck.GetRepoFirstCommitYear(".")

	// Open git repository once for all file operations
	repoRoot, _ := licensecheck.GetRepoRoot(".")

	updatedCount := 0
	anyFileUpdated := false
	var licensePath string

	// Producer/consumer: walk files (producer) and process them with a bounded
	// worker pool (consumers). This preserves existing semantics while
	// bounding concurrency and allowing the walk to run ahead of processors.
	ch := make(chan string, 1000)

	var wg sync.WaitGroup
	var updatedCount64 int64
	var anyFileUpdatedFlag int32
	var mu sync.Mutex

	workers := runtime.NumCPU() * 4
	if workers < 2 {
		workers = 2
	}

	// Start worker pool
	wg.Add(workers)
	for i := 0; i < workers; i++ {
		go func() {
			defer wg.Done()

			for path := range ch {
				// capture base and skip LICENSE files here as well
				base := filepath.Base(path)
				if strings.EqualFold(base, "LICENSE") || strings.EqualFold(base, "LICENSE.TXT") || strings.EqualFold(base, "LICENSE.MD") {
					mu.Lock()
					if licensePath == "" {
						licensePath = path
					}
					mu.Unlock()
					continue
				}

				if !dryRun {
					updated, err := licensecheck.UpdateCopyrightHeaderWithCache(path, targetHolder, configYear, false, repoFirstYear, repoRoot)
					if err == nil && updated {
						cmd.Printf("  %s\n", path)
						atomic.AddInt64(&updatedCount64, 1)
						atomic.StoreInt32(&anyFileUpdatedFlag, 1)
					}
				} else {
					needsUpdate, err := licensecheck.NeedsUpdateWithCache(path, targetHolder, configYear, false, repoFirstYear, repoRoot)
					if err == nil && needsUpdate {
						cmd.Printf("  %s\n", path)
						atomic.AddInt64(&updatedCount64, 1)
						atomic.StoreInt32(&anyFileUpdatedFlag, 1)
					}
				}
			}
		}()
	}

	// Producer: walk the tree and push files onto the channel
	go func() {
		_ = filepath.WalkDir(".", func(path string, d os.DirEntry, err error) error {
			// Check if file should be ignored
			if addlicense.FileMatches(path, ignoredPatterns) {
				return nil
			}

			if err != nil || d.IsDir() {
				return nil
			}

			// Non-ignored file -> enqueue for processing. If channel is full,
			// this will block until a worker consumes entries, which is fine.
			ch <- path
			return nil
		})
		close(ch)
	}()

	// wait for workers to finish
	wg.Wait()

	// finalize counts
	updatedCount = int(atomic.LoadInt64(&updatedCount64))
	anyFileUpdated = atomic.LoadInt32(&anyFileUpdatedFlag) != 0

	return updatedCount, anyFileUpdated, licensePath
}

// updateLicenseFile updates the LICENSE file with current year if any files were modified
func updateLicenseFile(cmd *cobra.Command, licensePath string, anyFileUpdated bool, dryRun bool) {
	// If no LICENSE file was found during the walk, nothing to do
	if licensePath == "" {
		return
	}

	targetHolder := conf.Project.CopyrightHolder
	if targetHolder == "" {
		targetHolder = "IBM Corp."
	}

	repoFirstYear, _ := licensecheck.GetRepoFirstCommitYear(".")
	configYear := conf.Project.CopyrightYear

	// Open git repository for LICENSE file operations
	repoRoot, _ := licensecheck.GetRepoRoot(".")

	// Update LICENSE file, forcing current year if any file was updated
	if !dryRun {
		updated, err := licensecheck.UpdateCopyrightHeaderWithCache(licensePath, targetHolder, configYear, anyFileUpdated, repoFirstYear, repoRoot)
		if err == nil && updated {
			cmd.Printf("\nUpdated LICENSE file: %s\n", licensePath)
		}
	} else {
		needsUpdate, err := licensecheck.NeedsUpdateWithCache(licensePath, targetHolder, configYear, anyFileUpdated, repoFirstYear, repoRoot)
		if err == nil && needsUpdate {
			cmd.Printf("\n[DRY RUN] Would update LICENSE file: %s\n", licensePath)
		}
	}
}
