// Copyright IBM Corp. 2017, 2025
// SPDX-License-Identifier: Apache-2.0

package cmd

import (
	"fmt"
	"os"

	"github.com/hashicorp/copywrite/addlicense"
	"github.com/hashicorp/go-hclog"
	"github.com/jedib0t/go-pretty/v6/text"
	"github.com/samber/lo"
	"github.com/spf13/cobra"
)

var updateCmd = &cobra.Command{
	Use:   "update",
	Short: "Updates copyright headers in all source code files",
	Long: `Recursively checks for all files in the given directory and subdirectories,
adding copyright statements and license headers to any that are missing them,
and replacing existing "Copyright (c) HashiCorp, Inc." headers with IBM headers.

Autogenerated files and common file types that don't support headers (e.g., prose)
will automatically be exempted. Any other files or folders should be added to the
header_ignore list in your project's .copywrite.hcl config. For help adding a
config, see the "copywrite init" command.`,
	GroupID: "common", // Let's put this command in the common section of the help
	PreRun: func(cmd *cobra.Command, args []string) {
		// Change directory if needed
		if dirPath != "." {
			err := os.Chdir(dirPath)
			cobra.CheckErr(err)
		}

		// Map command flags to config keys
		mapping := map[string]string{
			`spdx`:             `project.license`,
			`copyright-holder`: `project.copyright_holder`,
			`year1`:            `project.copyright_year1`,
			`year2`:            `project.copyright_year2`,
		}

		// update the running config with any command-line flags
		clobberWithDefaults := false
		err := conf.LoadCommandFlags(cmd.Flags(), mapping, clobberWithDefaults)
		if err != nil {
			cliLogger.Error("Error merging configuration", err)
		}
		cobra.CheckErr(err)

		// Input Validation
		isValidSPDX := addlicense.ValidSPDX(conf.Project.License)
		if conf.Project.License != "" && !isValidSPDX {
			err := fmt.Errorf("invalid SPDX license identifier: %s", conf.Project.License)
			cliLogger.Error("Error validating SPDX license", err)
			cobra.CheckErr(err)
		}
	},
	Run: func(cmd *cobra.Command, args []string) {
		if plan {
			cmd.Print(text.FgYellow.Sprint("Executing in dry-run mode. Rerun without the `--plan` flag to apply changes.\n\n"))
		}

		if conf.Project.License == "" {
			cmd.Printf("The --spdx flag was not specified, omitting SPDX license statements.\n\n")
		} else {
			cmd.Printf("Using license identifier: %s\n", conf.Project.License)
		}
		cmd.Printf("Using copyright holder: %v\n\n", conf.Project.CopyrightHolder)

		if len(conf.Project.HeaderIgnore) == 0 {
			cmd.Println("The project.header_ignore list was left empty in config. Processing all files by default.")
		} else {
			gha.StartGroup("Exempting the following search patterns:")
			for _, v := range conf.Project.HeaderIgnore {
				cmd.Println(text.FgCyan.Sprint(v))
			}
			gha.EndGroup()
		}
		cmd.Println("")

		// Append default ignored search patterns (e.g., GitHub Actions workflows)
		autoSkippedPatterns := []string{
			".github/workflows/**",
			".github/dependabot.yml",
			"**/node_modules/**",
		}
		ignoredPatterns := lo.Union(conf.Project.HeaderIgnore, autoSkippedPatterns)

		// Construct the configuration addLicense needs to properly format headers
		yearRange := ""
		if conf.Project.CopyrightYear1 > 0 && conf.Project.CopyrightYear2 > 0 {
			if conf.Project.CopyrightYear1 == conf.Project.CopyrightYear2 {
				// Use special marker to indicate both years were explicitly provided (even if same)
				yearRange = fmt.Sprintf("EXPLICIT_BOTH:%d", conf.Project.CopyrightYear1)
			} else {
				yearRange = fmt.Sprintf("%d, %d", conf.Project.CopyrightYear1, conf.Project.CopyrightYear2)
			}
		} else if conf.Project.CopyrightYear1 > 0 {
			// Mark that only year1 was provided
			yearRange = fmt.Sprintf("YEAR1_ONLY:%d", conf.Project.CopyrightYear1)
		} else if conf.Project.CopyrightYear2 > 0 {
			// Mark that only year2 was provided
			yearRange = fmt.Sprintf("YEAR2_ONLY:%d", conf.Project.CopyrightYear2)
		}

		licenseData := addlicense.LicenseData{
			Year:   yearRange,
			Holder: conf.Project.CopyrightHolder,
			SPDXID: conf.Project.License,
		}

		verbose := true

		// Wrap hclogger to use standard lib's log.Logger
		stdcliLogger := cliLogger.StandardLogger(&hclog.StandardLoggerOptions{
			// InferLevels must be true so that addLicense can set the log level via
			// log prefix, e.g. logger.Println("[DEBUG] this is inferred as a debug log")
			InferLevels: true,
		})

		// WARNING: because of the way we redirect cliLogger to os.Stdout, anything
		// prefixed with "[ERROR]" will not implicitly be written to stderr.
		// However, we propagate errors upward from addlicense and then run a
		// cobra.CheckErr on the return, which will indeed output to stderr and
		// return a non-zero error code.

		// Use command arguments if provided, otherwise default to current directory
		patterns := args
		if len(patterns) == 0 {
			patterns = []string{"."}
		}

		gha.StartGroup("The following files are being updated with headers:")
		err := addlicense.RunUpdate(ignoredPatterns, "only", licenseData, "", verbose, plan, patterns, stdcliLogger)
		gha.EndGroup()

		cobra.CheckErr(err)
	},
}

func init() {
	rootCmd.AddCommand(updateCmd)

	// These flags are only locally relevant
	updateCmd.Flags().StringVarP(&dirPath, "dirPath", "d", ".", "Path to the directory in which you wish to update headers")
	updateCmd.Flags().BoolVar(&plan, "plan", false, "Performs a dry-run, printing the names of all files that would be updated")

	// These flags will get mapped to keys in the the global Config
	updateCmd.Flags().StringP("spdx", "s", "", "SPDX-compliant license identifier (e.g., 'MPL-2.0')")
	updateCmd.Flags().StringP("copyright-holder", "c", "", "Copyright holder (default \"IBM Corp.\")")
	updateCmd.Flags().IntP("year1", "", 0, "Start year for copyright range (e.g., 2020)")
	updateCmd.Flags().IntP("year2", "", 0, "End year for copyright range (e.g., 2025)")
}
